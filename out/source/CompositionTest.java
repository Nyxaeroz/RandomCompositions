/* autogenerated by Processing revision 1286 on 2022-10-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CompositionTest extends PApplet {

int canvas_width;
int canvas_height;

Table table;
int total_palettes = 676;
int total_colors = 5;

 public void setup() {
  /* size commented out by preprocessor */;
  canvas_width = 1200;
  canvas_height = 800;
  
  table = loadTable("colors.csv", "csv, header");
  // int palette = 260;
  int palette = floor(random(676));

  PGraphics bg = createGraphics(canvas_width, canvas_height);
  bg.beginDraw();
  bg.background(get_color_from_palette(palette, 1));
  bg.endDraw();
  


  
  PGraphics lines1 = line_layer(canvas_width, canvas_height, get_color_from_palette(palette, 0));
  PGraphics lines2 = line_layer(canvas_width, canvas_height, get_color_from_palette(palette, 2));
  PGraphics intersect = createGraphics(canvas_width, canvas_height);
  PGraphics intersect2 = createGraphics(canvas_width, canvas_height);
  PGraphics circles = circle_layer(canvas_width, canvas_height, get_color_from_palette(palette, 3));
  
  intersect = intersection_layer(lines2, circles, canvas_width, canvas_height, get_color_from_palette(palette, 3));
  
  PGraphics merged = createGraphics(canvas_width, canvas_height);
  merged.beginDraw();
  merged.image(bg, 0, 0, canvas_width, canvas_height);
  // merged.image(lines1, 0, 0, canvas_width, canvas_height);
  // merged.image(lines2, 0, 0, canvas_width, canvas_height);
  // merged.image(intersect, 0, 0, canvas_width, canvas_height);
  merged.image(circles, 0, 0, canvas_width, canvas_height);
  merged.endDraw();
  
  //image(merged, 0, 0, canvas_width, canvas_height);
  
  PGraphics fuzzy = stochastic_pointillism(merged, 500000, 0, canvas_width, 0, canvas_height, 0);
  image(fuzzy, 0, 0, canvas_width, canvas_height);
}

 public void draw() {
  
}

// get color from pallete
// if rcol < 0 or rcol > nr of colors in the palette, choose a random color from the palette
 public int get_color_from_palette(int palette, int rcol) {
  int col = rcol;
  if (rcol < 0 || rcol > total_colors) {
    col = floor(random(total_colors));
  }
  int r = table.getInt(palette, col * 3);
  int g = table.getInt(palette, col * 3 + 1);
  int b = table.getInt(palette, col * 3 + 2);
  return color(r,g,b);
}

// Rotate vector v with angle angle around rot_center
//   1. translate v so that rot_center coincides with the origin
//   2. rotate
//   3. translate back with rot_center
// Returns rotated vector
 public PVector rotate_vector(float angle, PVector v, PVector rot_center) {
  float new_v_x = (v.x - rot_center.x) * cos(angle) - (v.y - rot_center.y) * sin(angle) + rot_center.x;
  float new_v_y = (v.x - rot_center.x) * sin(angle) + (v.y - rot_center.y) * cos(angle) + rot_center.y;

  return new PVector(new_v_x, new_v_y);
}

// create a layer with a random number of lines with a random angle
 public PGraphics line_layer(int xdim, int ydim, int c) {
  PGraphics layer = createGraphics(xdim, ydim);

  float angle = random(-.5f, .5f) * PI;
  int nr = PApplet.parseInt(random(1, 6));

  // calculate 'reference line'
  int y = PApplet.parseInt(random(0, ydim));
  PVector q1 = new PVector(-xdim, y);
  PVector q2 = new PVector(2*xdim, y);
  PVector center = new PVector(random(0, xdim), y);

  // corners of rotated line
  PVector p1 = rotate_vector(angle, q1, center);
  PVector p2 = rotate_vector(angle, q2, center);

  // draw nr many lines
  float offset = 0;
  for (int i = 0; i < nr; i++) {
    int stroke = PApplet.parseInt(random(5, 30));
    offset += .5f * stroke;
    layer.beginDraw();
    layer.noStroke();
    layer.beginShape();
    layer.fill(c);
    layer.vertex(p1.x + offset, p1.y);
    layer.vertex(p2.x + offset, p2.y);
    layer.vertex(p2.x + stroke + offset, p2.y);
    layer.vertex(p1.x + stroke + offset, p1.y);
    layer.endShape(CLOSE);
    layer.endDraw();

    offset += 1.5f * stroke;
  }

  print("Line layer angle:", angle, ", offset:", offset, ", nr:", nr, "\n");

  return layer;
}

// 
 public PGraphics intersection_layer(PGraphics layer1, PGraphics layer2, int w, int h, int c) {

  PGraphics intersect_mask = createGraphics(w, h);
  PGraphics intersect = createGraphics(w, h);

  PGraphics copy = createGraphics(w, h);
  copy.beginDraw();
  copy.loadPixels();
  arrayCopy(layer1.pixels, copy.pixels);
  copy.updatePixels();
  copy.endDraw();

  copy.beginDraw();
  copy.mask(layer2);
  copy.endDraw();

  intersect_mask.beginDraw();
  intersect_mask.background(0);
  intersect_mask.image(copy, 0, 0);
  intersect_mask.loadPixels();
  for (int i = 0; i < canvas_width * canvas_height; i++) {
    if (intersect_mask.pixels[i] != color(0,0,0)) {
      intersect_mask.pixels[i] = 255;
    }
  }
  intersect_mask.updatePixels();
  intersect_mask.endDraw();

  intersect.beginDraw();
  intersect.background(c);
  intersect.mask(intersect_mask);
  intersect.endDraw();

  return intersect;
}

// create a layer with a random number of randomly sized circles
// size inversely correlated to nr of circles
 public PGraphics circle_layer(int xdim, int ydim, int c) {
  PGraphics circles = createGraphics(canvas_width, canvas_height);
  float nr = random(3,10);
  float radius_mean = map(nr, 3, 10, 200, 20);
  circles.beginDraw();
  for (int i = 0; i < nr; i++) {
    circles.fill(c);
    circles.noStroke();
    circles.circle(random(0, canvas_width), random(0, canvas_height), randomGaussian() * radius_mean);
  }
  circles.endDraw();
  return circles;
}

 public PGraphics stochastic_pointillism(PGraphics base_layer,
                           int density, 
                           float rxmin, 
                           float rxmax, 
                           float rymin, 
                           float rymax, 
                           int offset){
  PGraphics layer = createGraphics(PApplet.parseInt(rxmax - rxmin), PApplet.parseInt(rymax - rymin));
                             
  int variation;
  float rx,ry;
  int pix;
  float r,g,b;
  image(base_layer, 0, 0, PApplet.parseInt(rxmax - rxmin), PApplet.parseInt(rymax - rymin));
  
  layer.beginDraw();
  for(int i = 0; i <= density; i++) {
    rx = random(rxmin-offset,rxmax+1+offset);
    ry = random(rymin-offset,rymax+1+offset);
    pix = get(PApplet.parseInt(rx),PApplet.parseInt(ry));
    r = red(pix);
    g = green(pix);
    b = blue(pix);
    
    layer.strokeCap(ROUND);
    variation=PApplet.parseInt(random(1,4));
    switch(variation){
      case 1:
      layer.stroke(r-10,g-10,b-10);
      break;
      case 2:
      layer.stroke(r-5,g-5,b-5);
      break;
      case 3:
      layer.stroke(r-random(1,6),g-random(1,6),b-random(1,6));
      break;
    }
    layer.strokeWeight(2);
    layer.point(rx,ry);
  }
 layer.endDraw();
 
 return layer;
}


  public void settings() { size(1200, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CompositionTest" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
